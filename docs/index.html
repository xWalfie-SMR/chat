<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Chat SMR</title>
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <!-- Username Prompt Overlay -->
    <div id="username-prompt" class="modal hidden">
      <div class="modal-content">
        <h2>Bienvenido al Chat</h2>
        <p>Escribe tu nombre de usuario:</p>
        <input
          id="username-input"
          type="text"
          placeholder="Usuario"
          autocomplete="off"
          autofocus
        />
        <button id="username-submit">Entrar</button>
      </div>
    </div>

    <!-- Reload Notification -->
    <div id="reload-notification" class="notification hidden">
      <div class="notification-content">
        <p>¡El servidor se ha actualizado!</p>
        <p>
          La página se recargará en
          <span id="reload-countdown">5</span> segundos...
        </p>
        <button id="reload-now">Recargar ahora</button>
      </div>
    </div>

    <!-- Settings Menu -->
    <div id="settings-menu" class="settings-menu hidden">
      <button id="change-username-btn">Cambiar usuario</button>
      <button id="logout-btn">Cerrar sesión</button>
    </div>

    <!-- Change Username Prompt -->
    <div id="change-username-prompt" class="modal hidden">
      <div class="modal-content">
        <h2>Cambiar Usuario</h2>
        <p>Escribe tu nuevo nombre de usuario:</p>
        <input
          id="new-username-input"
          type="text"
          placeholder="Nuevo usuario"
          autocomplete="off"
        />
        <button id="new-username-submit">Cambiar</button>
        <button id="new-username-cancel" class="button-secondary">Cancelar</button>
      </div>
    </div>

    <!-- Logout Confirmation -->
    <div id="logout-prompt" class="modal hidden">
      <div class="modal-content">
        <h2>Cerrar Sesión</h2>
        <p>¿Estás seguro de que quieres cerrar sesión?</p>
        <button id="logout-confirm">Cerrar sesión</button>
        <button id="logout-cancel" class="button-secondary">Cancelar</button>
      </div>
    </div>

    <div id="chat"></div>
    <!-- Scroll to bottom arrow -->
    <div id="scroll-arrow" class="hidden">&#8595;</div>

    <!-- Input container with settings button -->
    <div id="input-container">
      <input
        id="input"
        placeholder="Escribe tu mensaje y presiona Enter..."
        autocomplete="off"
        disabled
      />
      <button id="settings-btn" class="settings-button" title="Configuración">
        <svg
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M12 15.5A3.5 3.5 0 1 0 12 8.5a3.5 3.5 0 0 0 0 7z"
            fill="#888"
          />
          <path
            d="M19.43 12.98c.04-.32.07-.65.07-.98s-.03-.66-.07-.98l2.11-1.65a.5.5 0 0 0 .12-.65l-2-3.46a.5.5 0 0 0-.61-.22l-2.49 1a7.03 7.03 0 0 0-1.69-.98l-.38-2.65A.5.5 0 0 0 14 2h-4a.5.5 0 0 0-.5.43l-.38 2.65a7.03 7.03 0 0 0-1.69.98l-2.49-1a.5.5 0 0 0-.61.22l-2 3.46a.5.5 0 0 0 .12.65l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65a.5.5 0 0 0-.12.65l2 3.46a.5.5 0 0 0 .61.22l2.49-1c.53.38 1.1.7 1.69.98l.38 2.65A.5.5 0 0 0 10 22h4a.5.5 0 0 0 .5-.43l.38-2.65c.59-.28 1.16-.6 1.69-.98l2.49 1a.5.5 0 0 0 .61-.22l2-3.46a.5.5 0 0 0-.12-.65l-2.11-1.65z"
            stroke="#888"
            stroke-width="2"
            fill="none"
          />
        </svg>
      </button>
    </div>

    <style>
      /* Hide scrollbar for chat */
      #chat {
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* IE 10+ */
      }
      #chat::-webkit-scrollbar {
        display: none; /* Chrome, Safari, Opera */
      }
    </style>

    <script>
      const WEBSOCKET_SERVER = "wss://chat-cp1p.onrender.com";

      // Elements
      const chat = document.getElementById("chat");
      const input = document.getElementById("input");
      const usernamePrompt = document.getElementById("username-prompt");
      const usernameInput = document.getElementById("username-input");
      const usernameSubmit = document.getElementById("username-submit");
      const reloadNotification = document.getElementById("reload-notification");
      const reloadCountdown = document.getElementById("reload-countdown");
      const reloadNowBtn = document.getElementById("reload-now");
      const settingsBtn = document.getElementById("settings-btn");
      const settingsMenu = document.getElementById("settings-menu");
      const changeUsernameBtn = document.getElementById("change-username-btn");
      const logoutBtn = document.getElementById("logout-btn");
      const scrollArrow = document.getElementById("scroll-arrow");
      const changeUsernamePrompt = document.getElementById("change-username-prompt");
      const newUsernameInput = document.getElementById("new-username-input");
      const newUsernameSubmit = document.getElementById("new-username-submit");
      const newUsernameCancel = document.getElementById("new-username-cancel");
      const logoutPrompt = document.getElementById("logout-prompt");
      const logoutConfirm = document.getElementById("logout-confirm");
      const logoutCancel = document.getElementById("logout-cancel");

      // State
      let ws = null;
      let username = "";
      let isAuthenticated = false;
      let serverStartTime = null;
      let reconnectAttempt = 0;
      let reconnectTimer = null;
      let isLoggingOut = false;
      const userColors = {};

      // Device ID - persistent across sessions
      let deviceId = localStorage.getItem("deviceId");
      if (!deviceId) {
        deviceId = `${Math.random().toString(36).substr(2, 9)}-${Date.now()}`;
        localStorage.setItem("deviceId", deviceId);
        console.log("Generated deviceId:", deviceId);
      }

      // --- HELPER FUNCTIONS ---

      function getUserColor(name) {
        if (!userColors[name]) {
          const index = Object.keys(userColors).length % 6;
          userColors[name] = `usercolor${index}`;
        }
        return userColors[name];
      }

      function formatTime(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleTimeString("es-ES", {
          hour: "2-digit",
          minute: "2-digit",
        });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      function addMessage(msg, timestamp) {
        const timeStr = formatTime(timestamp);

        // Parse username from message
        const nameMatch = msg.match(/^\[([^\]]+)\]/);

        if (nameMatch) {
          const name = nameMatch[1];
          const content = msg.substring(nameMatch[0].length).trim();
          const colorClass = getUserColor(name);

          chat.innerHTML += `<div class="message">
        <span class="username ${colorClass}">[${escapeHtml(name)}]</span>
        <span class="message-content">${escapeHtml(content)}</span>
        <span class="timestamp">${timeStr}</span>
      </div>`;
        } else {
          // System message
          chat.innerHTML += `<div class="message">
        <span class="message-content">${escapeHtml(msg)}</span>
        <span class="timestamp">${timeStr}</span>
      </div>`;
        }

        chat.scrollTop = chat.scrollHeight;
        updateScrollArrow();
      }

      // Show/hide scroll arrow if not at bottom
      function updateScrollArrow() {
        // Only show arrow if chat is scrollable and not at bottom
        if (
          chat.scrollHeight - chat.clientHeight > 2 &&
          chat.scrollTop + chat.clientHeight < chat.scrollHeight - 2
        ) {
          scrollArrow.classList.remove("hidden");
        } else {
          scrollArrow.classList.add("hidden");
        }
      }

      function showReloadNotification() {
        reloadNotification.classList.remove("hidden");
        let seconds = 5;
        reloadCountdown.textContent = seconds;

        const interval = setInterval(() => {
          seconds--;
          reloadCountdown.textContent = seconds;
          if (seconds <= 0) {
            clearInterval(interval);
            location.reload();
          }
        }, 1000);

        reloadNowBtn.onclick = () => {
          clearInterval(interval);
          location.reload();
        };
      }

      // --- WEBSOCKET CONNECTION ---

      function connect() {
        if (ws && ws.readyState === WebSocket.OPEN) return;

        console.log("Connecting to:", WEBSOCKET_SERVER);
        ws = new WebSocket(WEBSOCKET_SERVER);

        ws.onopen = () => {
          console.log("✓ Connected");

          const savedUsername = localStorage.getItem("chatUsername");
          const isReconnect = reconnectAttempt > 0;

          if (savedUsername) {
            // Auto-login with saved username
            authenticate(savedUsername, isReconnect);
          } else {
            // Show username prompt for new users
            usernamePrompt.classList.remove("hidden");
            usernameInput.focus();
          }

          reconnectAttempt = 0;
        };

        ws.onmessage = (evt) => {
          const data = JSON.parse(evt.data);

          switch (data.type) {
            case "serverInfo":
              handleServerInfo(data);
              break;

            case "authenticated":
              handleAuthenticated(data);
              break;

            case "history":
              data.messages.forEach((m) => addMessage(m.msg, m.timestamp));
              break;

            case "chat":
              addMessage(data.msg, data.timestamp);
              break;

            case "usernameChanged":
              // Transfer color
              if (userColors[data.oldUsername]) {
                userColors[data.username] = userColors[data.oldUsername];
              }
              username = data.username;
              localStorage.setItem("chatUsername", username);
              break;

            case "pong":
              if (data.serverStartTime !== serverStartTime) {
                showReloadNotification();
              }
              break;

            case "error":
              console.error("Server error:", data.msg);
              addMessage(`❌ Error: ${data.msg}`, Date.now());
              break;

            case "replaced":
              console.log("Connection replaced");
              break;
          }
        };

        ws.onclose = () => {
          console.log("✗ Disconnected");
          isAuthenticated = false;
          input.disabled = true;

          // Don't auto-reconnect if this is an intentional logout
          if (isLoggingOut) {
            return;
          }

          if (!reconnectTimer) {
            const delay = Math.min(1000 * Math.pow(2, reconnectAttempt), 30000);
            reconnectAttempt++;

            addMessage(
              `Desconectado. Reconectando en ${Math.round(delay / 1000)}s...`,
              Date.now()
            );

            reconnectTimer = setTimeout(() => {
              reconnectTimer = null;
              connect();
            }, delay);
          }
        };

        ws.onerror = (err) => {
          console.error("WebSocket error:", err);
        };
      }

      function authenticate(name, isReconnect = false) {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({
              type: "auth",
              username: name,
              deviceId: deviceId,
              isReconnect: isReconnect,
            })
          );
        }
      }

      function handleServerInfo(data) {
        const newStartTime = data.startTime;
        const savedStartTime = localStorage.getItem("serverStartTime");

        if (
          savedStartTime &&
          savedStartTime !== newStartTime.toString() &&
          serverStartTime
        ) {
          showReloadNotification();
        }

        serverStartTime = newStartTime;
        localStorage.setItem("serverStartTime", newStartTime.toString());
      }

      function handleAuthenticated(data) {
        console.log("✓ Authenticated as:", data.username);
        username = data.username;
        isAuthenticated = true;
        input.disabled = false;
        input.focus();

        usernamePrompt.classList.add("hidden");

        localStorage.setItem("chatUsername", username);

        if (data.history && data.history.length > 0) {
          data.history.forEach((m) => addMessage(m.msg, m.timestamp));
        }
      }

      // --- EVENT LISTENERS ---

      usernameSubmit.addEventListener("click", () => {
        const name = usernameInput.value.trim();

        if (name) {
          authenticate(name);
        }
      });

      usernameInput.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter") {
          usernameSubmit.click();
        }
      });

      input.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter" && isAuthenticated) {
          const msg = input.value.trim();

          if (msg) {
            ws.send(
              JSON.stringify({
                type: "chat",
                msg: msg,
                timestamp: Date.now(),
              })
            );
            input.value = "";
          }
        }
      });

      settingsBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        settingsMenu.classList.toggle("hidden");
      });

      // Close settings menu when clicking outside
      document.addEventListener("click", (e) => {
        if (!settingsMenu.classList.contains("hidden") && 
            !settingsMenu.contains(e.target) && 
            e.target !== settingsBtn) {
          settingsMenu.classList.add("hidden");
        }
      });

      changeUsernameBtn.addEventListener("click", () => {
        settingsMenu.classList.add("hidden");
        changeUsernamePrompt.classList.remove("hidden");
        newUsernameInput.value = username;
        newUsernameInput.focus();
        newUsernameInput.select();
      });

      newUsernameSubmit.addEventListener("click", () => {
        const newName = newUsernameInput.value.trim();

        if (newName && newName !== username) {
          ws.send(
            JSON.stringify({
              type: "changeUsername",
              newUsername: newName,
            })
          );
          changeUsernamePrompt.classList.add("hidden");
        }
      });

      newUsernameCancel.addEventListener("click", () => {
        changeUsernamePrompt.classList.add("hidden");
      });

      newUsernameInput.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter") {
          newUsernameSubmit.click();
        } else if (evt.key === "Escape") {
          changeUsernamePrompt.classList.add("hidden");
        }
      });

      logoutBtn.addEventListener("click", () => {
        settingsMenu.classList.add("hidden");
        logoutPrompt.classList.remove("hidden");
      });

      logoutConfirm.addEventListener("click", () => {
        // Hide the logout confirmation modal
        logoutPrompt.classList.add("hidden");
        
        // Set logout flag to prevent auto-reconnect in onclose handler
        isLoggingOut = true;
        
        // Clear any pending reconnect timer
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
        
        // Close the WebSocket connection
        if (ws) {
          ws.close();
          ws = null;
        }
        
        // Clear all state
        username = "";
        isAuthenticated = false;
        localStorage.removeItem("chatUsername");
        
        // Clear the chat history
        chat.innerHTML = "";
        
        // Disable input
        input.disabled = true;
        input.value = "";
        
        // Clear username input
        usernameInput.value = "";
        
        // Show the username prompt
        usernamePrompt.classList.remove("hidden");
        usernameInput.focus();
        
        // Reset logout flag and reconnect with fresh state
        isLoggingOut = false;
        reconnectAttempt = 0;
        connect();
      });

      logoutCancel.addEventListener("click", () => {
        logoutPrompt.classList.add("hidden");
      });

      // Close modals when clicking outside
      changeUsernamePrompt.addEventListener("click", (e) => {
        if (e.target === changeUsernamePrompt) {
          changeUsernamePrompt.classList.add("hidden");
        }
      });

      logoutPrompt.addEventListener("click", (e) => {
        if (e.target === logoutPrompt) {
          logoutPrompt.classList.add("hidden");
        }
      });

      // Global escape key handler to close modals
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          if (!logoutPrompt.classList.contains("hidden")) {
            logoutPrompt.classList.add("hidden");
          } else if (!changeUsernamePrompt.classList.contains("hidden")) {
            changeUsernamePrompt.classList.add("hidden");
          }
        }
      });

      // Initial connection
      connect();

      scrollArrow.innerHTML = "↓";
      function updateScrollArrow() {
        // Only show arrow if chat is scrollable and not at bottom
        if (
          chat.scrollHeight - chat.clientHeight > 2 &&
          chat.scrollTop + chat.clientHeight < chat.scrollHeight - 2
        ) {
          scrollArrow.classList.remove("hidden");
        } else {
          scrollArrow.classList.add("hidden");
        }
      }
      chat.addEventListener("scroll", updateScrollArrow);
      scrollArrow.addEventListener("click", () => {
        chat.scrollTo({ top: chat.scrollHeight, behavior: "smooth" });
        updateScrollArrow();
      });
    </script>
  </body>
</html>
